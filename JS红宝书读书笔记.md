# JS红宝书读书笔记

## 第一章	什么是 JS ？

​	略

## 第二章	HTML中的JS

​	略

## 第三章	语言基础

### 3.1	语法

### 3.2	关键字和保留字

### 3.3	变量

### 3.4	 数据类型

### 3.5	操作符

### 3.6	语句

### 3.7	函数

### 3.8	小结

## 第四章 	变量、作用域 与内存

###	4.1	变量

#### 4.1.1	原始值和引用值

​	原始值：symbol	string	number	boolean	null	undefined

​	引用值：多个值构成的对象

​	JS不允许直接访问内存位置，所以操作对象的时候，实际操作的是对该对象的引用。

#### 4.1.2	动态属性

​	引用值可以通过 Object.property 来动态增加属性。

#### 4.1.3	复制

​	原始值复制的时候会是拷贝一个新的副本赋值，而引用值复制的时候只是复制了一个引用，本质上指向堆内存中的同一个对象。

#### 4.1.4	函数传值

​	JS函数传值本质上全部都是复制传值，当传入一个对象时，也会复制一个引用值给函数内的局部变量，使得函数内的局部变量也指向这个对象，看起来似乎传入了这个对象，实际上只是复制了对象的引用。

#### 4.1.5	判断变量类型

​	typeof 操作符适合判断原始值类型，instanceof 适合判断引用值类型。

​	所有引用值都是 Object 的实例。

### 4.2	执行上下文和作用域

​	函数会创造一个局部作用域，嵌套的函数就形成了一个作用域链。

​	作用域决定了可以访问的变量和函数的范围，作用域链就决定了访问的先后顺序。

​	举例：在浏览器中，作用域链从 window（全局作用域） --> arguments（函数默认参数对象，在这个场景下可称为活动对象）

#### 4.2.1	作用域增强

- with语句
- try / catch 的 catch 块

例子：

```js
function buildUrl() {
	let qs = "?debug=ture";
	
	with (location) {
		let url = href + qs;	// 此处就改变了作用域，href === location.href
	}
	
	return url;
}
```

#### 4.2.2	变量声明

ES6新变量和var作用域方面的区别：

使用 var 声明变量

> 变量会被自动添加到最近的作用域上，并会被拿到函数或全局作用于的顶部，位于作用域中所有代码之前，这个现象叫做`变量提升`。
>
> ```js
> console.log(name);	// undefinded 而不是 Reference Error
> var name = 'Jack';
> ```
>
> 

使用 let 声明变量

> 块级作用域，只在 { } 内有效，且不会变量提升。
>
> ```js
> console.log(z);	// Reference Error
> let z = 123;使用 let 声明变量
> ```

使用 const 声明常量

> 除了初始化后不能修改，其他特性与 let 相同。
>
> 但是如果声明的是一个对象，那么添加属性不受限制，可以通过 `Object.freeze()`使得添加属性静默失败。
>
> ```js
> const o1 = {};
> o1 = {}; // TypeError: Assignment to a constant variable 
> 
> const o2 = {};
> o2.name = 'Jack';
> console.log(o2); // 'Jack'
> 
> const o3 = Object.freeze({});
> o3.name = 'Jack';
> console.log(o3); // undefined
> ```

### 4.3	垃圾回收

#### 4.3.1	标记清理法

​	基本的垃圾回收算法称为**“标记-清除”**，定期执行以下“垃圾回收”步骤:

- 垃圾回收器获取根并**“标记”**(记住)它们。
- 然后它访问并“标记”所有来自它们的引用。
- 然后它访问标记的对象并标记它们的引用。所有被访问的对象都被记住，以便以后不再访问同一个对象两次。
- 以此类推，直到有未访问的引用(可以从根访问)为止。
- 除标记的对象外，所有对象都被删除。

例如，对象结构如下:

![图片描述](https://segmentfault.com/img/bVbqd7y)

我们可以清楚地看到右边有一个“不可到达的块”。现在让我们看看**“标记并清除”**垃圾回收器如何处理它。

**第一步标记根**

![图片描述](https://segmentfault.com/img/bVbqd7V)

**然后标记他们的引用**

![图片描述](https://segmentfault.com/img/bVbqd71)

以及子孙代的引用:

![图片描述](https://segmentfault.com/img/bVbqd8a)

现在进程中不能访问的对象被认为是不可访问的，将被删除:

![图片描述](https://segmentfault.com/img/bVbqd8A)

这就是垃圾收集的工作原理。JavaScript引擎应用了许多优化，使其运行得更快，并且不影响执行。

#### 4.3.2	引用计数法

为每个变量分配一个被引用数，当被变量被声明时，引用数+1；当变量引用的值被赋值给另外一个变量，引用数+1；当保存这个值的引用的变量被覆盖了，引用数-1。

当引用数变为 0 的时候，任何变量都没有引用该值，则回收该值的内存。

> 引用计数法存在循环引用的问题，即两个对象相互应用，导致值无法被回收，所以逐渐弃用。

#### 4.3.3	性能

GC基于已分配对象的大小和数量来判断何时进行。

#### 4.3.4	内存管理

1. 把不需要的对象赋值为 null ，从而解除引用。
2. 使用 const 和 let 声明，块级作用域可以更早触发GC。
3. 在构造函数内一次性声明所有属性，从而配和 V8 引擎的隐藏类。
4. 避免内存泄漏（不意外声明全局变量、避免使用内部闭包）。
5. 使用静态分配和对象池（极端，很少使用）。

